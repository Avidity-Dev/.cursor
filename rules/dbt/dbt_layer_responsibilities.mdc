---
globs: "**/transforms/**"
alwaysApply: false
---

# DBT Layer Responsibilities

This rule defines the distinct responsibilities and purposes of the three main dbt layers: staging, intermediate, and marts. Following these guidelines ensures clean architecture, maintainable models, and clear separation of concerns.

## Overview

In dbt, the staging and intermediate layers serve very different but complementary roles. Think of them as rungs on a ladder from raw source data to clean, business-ready marts.

## ğŸŸ¦ Staging Layer (stg\_\*)

**Purpose:**
The staging layer is the first transformation stop after raw data is ingested. Its responsibility is to clean up and standardize source tables so they're easier to work with downstream.

**File Naming Convention:** `stg_[source_name]__table_name.sql`

**Typical Responsibilities:**

- One-to-one mapping with source tables (stg\_\* models usually mirror a raw table)
- Rename cryptic column names into something human-readable
- Apply basic type casting (e.g., strings to dates, integers to booleans)
- Normalize column conventions (snake_case, consistent naming)
- Add basic derived columns (e.g., parsed timestamps, surrogate keys)
- Handle simple deduplication or removing obvious junk records
- Basic data quality checks (null handling, format validation)

**What NOT to do in staging:**

- Complex business logic
- Multi-table joins
- Heavy aggregations
- Final metric calculations
- **Schema alignment for UNIONs** (this belongs in intermediate layer)

**Important: Schema Alignment Principle**

When you have multiple sources that will be UNIONed together (e.g., Veeva Network + OpenData):

- âœ… **Staging**: Each staging model represents its source table one-to-one
- âœ… **Staging**: Use the actual column names from each source
- âŒ **Staging**: Don't add NULL columns just to match another source's schema
- âœ… **Intermediate**: Handle schema alignment with explicit CAST(NULL AS type) for missing fields

**Example:**

```sql
-- âœ… GOOD: stg_vn_hco.sql (Network has top_parent)
select
    top_parent__v as top_parent
from source

-- âœ… GOOD: stg_hco.sql (OpenData doesn't have top_parent, so don't add it)
select
    -- No top_parent column here!
from source

-- âœ… GOOD: int_hco_unified.sql (Intermediate adds NULL for OpenData)
select
    cast(null as varchar) as top_parent  -- Add missing column for UNION
from {{ ref('stg_hco') }}
```

**Analogy:** It's like tidying raw ingredientsâ€”washing veggies, measuring spices, trimming fatâ€”before you start cooking.

## ğŸŸ© Intermediate Layer (int\_\*)

**Purpose:**
The intermediate layer is a semantic modeling step between staging and marts. It's where you start blending data from multiple staging models to represent logical business entities or concepts.

**File Naming Convention:** `int_[business_concept]__description.sql`

**Typical Responsibilities:**

- Joins across staging tables (e.g., linking customers to transactions, products, campaigns)
- Introduce business logic that is too complex or heavy for staging, but not yet at the "final metric" level
- Create reusable building blocks: dimensions and fact-like datasets that downstream marts can leverage
- Filter/aggregate to the level of business concepts (e.g., "active customers," "first orders," "product hierarchy")
- Enforce consistency by centralizing common transformations instead of repeating them in multiple marts
- Apply business rules and logic (e.g., customer status calculations, product categorization)
- **Schema alignment for UNIONs** (normalize columns from different sources)
- **Deduplication logic** (e.g., "Network overrides OpenData")
- **Enrichment joins** (LEFT JOIN to preserve all records while adding attributes)

**What NOT to do in intermediate:**

- Final reporting metrics or KPIs
- Complex aggregations meant for end-user consumption
- Presentation-layer formatting
- Direct exposure to business users

**Analogy:** This is your mise en placeâ€”assembling ingredients into usable prep bowls. You're not plating the dish yet, but you've got sautÃ©ed onions, a simmering sauce, and chopped herbs ready.

## ğŸŸ¨ Marts Layer (dim*\*, fct*\*)

**Purpose:**
The marts layer represents the final, business-ready datasets that are exposed to end users, reports, and BI tools. These are the "finished products" of the dbt transformation pipeline.

**File Naming Conventions:**

- Dimensions: `dim_[entity]__description.sql`
- Facts: `fct_[business_process]__description.sql`

**Typical Responsibilities:**

- Final aggregations and calculations
- Business metrics and KPIs
- Data at the right grain for reporting
- Optimized for query performance
- Ready for BI tools and end-user consumption
- Apply final business logic and formatting

**What to consider:**

- Query performance optimization
- Appropriate data types for reporting tools
- Clear column names for business users
- Documentation for business stakeholders

## ğŸš¦ Decision Framework

When creating a new model, ask:

1. **Is this cleaning raw data into a usable form?** â†’ Staging layer
2. **Is this combining sources or applying business definitions?** â†’ Intermediate layer
3. **Is this creating final metrics or reporting outputs?** â†’ Marts layer

## ğŸ“‹ Validation Checklist

When reviewing dbt models:

### Staging Models:

- [ ] One-to-one relationship with source tables?
- [ ] Only basic cleaning and type casting?
- [ ] No complex joins or business logic?
- [ ] Clear column naming conventions?
- [ ] Basic data quality applied?

### Intermediate Models:

- [ ] Building on staging models only?
- [ ] Creating reusable business concepts?
- [ ] Appropriate level of aggregation?
- [ ] No final reporting metrics?
- [ ] Business logic clearly documented?

### Mart Models:

- [ ] Using intermediate models as sources?
- [ ] Final, consumable format?
- [ ] Clear for business users?
- [ ] Performance optimized?
- [ ] Well documented for stakeholders?

## ğŸ’¡ Best Practices

1. **Skip intermediate if simple:** Some teams skip the intermediate layer if their models are simple, but in mature dbt projects it's invaluable for avoiding duplication and making business logic explicit.

2. **Dependencies flow downward:** Staging â†’ Intermediate â†’ Marts. Never go upward against this flow.

3. **Keep staging simple:** The staging layer should be as lightweight as possible. Move complex logic to intermediate where it can be tested and reused.

4. **Document business logic:** Any non-obvious business rules should be clearly documented in intermediate models.

5. **Test incrementally:** Test at each layer to catch issues early in the transformation pipeline.

## ğŸ—ï¸ Example Project Structure

```
models/
â”œâ”€â”€ staging/
â”‚   â”œâ”€â”€ stg_customers__raw.sql
â”‚   â”œâ”€â”€ stg_orders__raw.sql
â”‚   â””â”€â”€ stg_products__raw.sql
â”œâ”€â”€ intermediate/
â”‚   â”œâ”€â”€ int_customer_orders__joined.sql
â”‚   â”œâ”€â”€ int_active_customers__filtered.sql
â”‚   â””â”€â”€ int_product_hierarchy__categorized.sql
â””â”€â”€ marts/
    â”œâ”€â”€ dim_customers__active.sql
    â”œâ”€â”€ dim_products__categorized.sql
    â””â”€â”€ fct_orders__aggregated.sql
```
